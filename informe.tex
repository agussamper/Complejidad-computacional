\documentclass{article}
\usepackage[spanish]{babel}
\usepackage{graphicx} % Required for inserting images
\usepackage{lipsum}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{setspace}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\usepackage{amsmath}

\setlength{\parskip}{2pt}

\spacing{1.3}

\title{Complejidad computacional}
\author{Agustín Samper, Facundo Llaudet y Guillermo Pereyra}
\date{November 2023}

\begin{document}
\maketitle
\section*{Introducción}
\indent La mayoría de los problemas que consideramos en la materia son de 
carácter general, aplicados a todos los miembros de alguna familia de
grafos o dígrafos. Estos problemas pueden ser clasificados dependiendo de su nivel de dificultad. \newline
\indent La dificultad de un problema depende del tiempo empleado para
devolver una respuesta dado un input en específico. \newline
\indent Estos problemas son resueltos mediantes algoritmos, los cuales
los definimos como procedimientos computacionales bien definidos que 
aceptan cualquier instancia del problema como entrada y retorna una
solución al problema como salida. Por ejemplo,
el algoritmo de Prim acepta como entrada un grafo ponderado y retorna un
árbol óptimo. \newline
\indent Por instancia de un problema, nos referimos al
problema aplicado a un miembro específico de la familia. Por ejemplo,
una instancia del problema del árbol recubridor de peso mínimo es el
problema de encontrar un árbol óptimo (árbol recubridor de peso mínimo)
para un grafo ponderado particular. \newline
\indent Entonces, cuando hablamos del nivel de dificultad de un problema, nos
referimos a la complejidad computacional de un algoritmo que lo resuelve,
al número de pasos básicos computacionales (como operaciones aritméticas y comparaciones)
requeridas para su ejecución. Este número depende claramente del tamaño y de la 
naturaleza de la entrada. \newline
\indent Diremos que un algoritmo es polinomial cuando el número de
operaciones que efectúa está acotado por una función polinomial en
el tamaño de su entrada, el algoritmo es llamado \textit{algoritmo
de tiempo polinomial}. Además, está calificado como \textit{tiempo lineal}
si el polinomio es una función lineal, \textit{tiempo cuadrático} si 
es una función cuadrática y así sucesivamente.

\section*{La clase \textit{\textbf{$\mathcal{P}$}}}
La importancia de algoritmos de tiempo polinomial es que estos algoritmos
generalmente son computacionalmente realizables, incluso para grandes
tamaños de entrada. \newline
\indent El tipo de problemas resolubles mediante algoritmos de tiempo polinómico
lo denotaremos como problemas de clase $\mathcal{P}$.\newline
\indent Un ejemplo de algoritmo en tiempo polinomial (clase \textit{$\mathcal{P}$})
es BFS (breadth-first search) para el cual, cada arista es examinada por una posible
inclusión en el árbol solamente dos veces. Otro ejemplo es DFS (depth-first serach)
donde ocurre lo mismo que en BFS. Por lo tanto, cualquiera de estos son
lineales en el número de aristas. \newline
\indent En contraste a los algoritmos de tiempo polinomial, los
algoritmos cuya complejidad es exponencial en el tamaño de su
entrada tienen tiempos de ejecución, los cuales los hacen inutilizables,
incluso para entradas de un tamaño moderado. Por ejemplo, un algoritmo
el cual verifica si dos grafos con n vértices son isomorfos o no 
considerando todas las n! biyecciones entre sus conjuntos de vértices es
realizable solo para pequeños valores de n (específicamente no mayor a 20).\newline
\indent Estos algoritmos dan lugar a una nueva clase de problemas que llamaremos
problemas de clase \textit{$\mathcal{N}\mathcal{P}$}.\newline

\indent
\section*{Las Clases \textit{\textbf{$\mathcal{N}\mathcal{P}$}} y
\textit{\textbf{co-$\mathcal{N}\mathcal{P}$}}}
\indent Necesitamos primero definir que un \textit{problema de decisión}
es una pregunta cuya respuesta es 'sí' o 'no'. Tal problema pertenece
a la clase \textit{$\mathcal{P}$} si existe un algoritmo de tiempo
polinomial que resuelve cualquier instancia del problema en tiempo
polinomial. En cambio, dada una instancia
cualquiera del problema cuya respuesta es 'sí', si existe alguna forma de 
certificar que la afirmación es válida en tiempo polinomial, entonces este problema
pertenece a la clase \textit{$\mathcal{N}\mathcal{P}$}. Análogamente,
un problema pertenecerá a la clase \textit{co-$\mathcal{N}\mathcal{P}$} si para
una instancia cualquiera del problema cuya respuesta es 'no', existe una forma
de certificar dicha respuesta en tiempo polinomial.\newline
\indent Es inmediato ver que $\textit{$\mathcal{P}$} \subseteq \textit{$\mathcal{N}\mathcal{P}$}$, pues por definición, para un problema \textit{$\mathcal{P}$} existe un algoritmo que resuelve en tiempo polinomial cualquier instancia del problema, en particular lo hará para aquellas cuya respuesta es 'sí'. Siguiendo la misma lógica para las instancias cuyas respuestas es 'no', llegamos a la conclusión que $\textit{$\mathcal{P}$} \subseteq \textit{co-$\mathcal{N}\mathcal{P}$}$. Entonces, podemos ver que:\newline
\begin{align*}
    \textit{$\mathcal{P}$} \subseteq \textit{$\mathcal{N}\mathcal{P}$} \cap \textit{co-$\mathcal{N}\mathcal{P}$}
\end{align*} 


\indent PONER UN EJEMPLO, PROBLEM 8.1 (?  \newline
\newline
\newline
\newline



\indent Hemos señalado tres relaciones de inclusión entre las clases \textit{$\mathcal{P}$}, \textit{$\mathcal{N}\mathcal{P}$} y \textit{co-$\mathcal{N}\mathcal{P}$}, y es natural preguntarse si estas inclusiones son adecuadas. Debido a que \textit{$\mathcal{P}$} = \textit{$\mathcal{N}\mathcal{P}$} si y solo si \textit{$\mathcal{P}$} = \textit{co-$\mathcal{N}\mathcal{P}$}, surgen dos preguntas fundamentales, ambas de las cuales se han planteado como conjeturas. \newline

\setlength{\fboxsep}{10pt}
\noindent\fbox{\begin{minipage}{\dimexpr\textwidth-2\fboxsep-2\fboxrule\relax}
 \subsection*{La conjetura de Cook-Edmonds-Levin}
        \begin{align*}
            \textit{$\mathcal{P}$}  \neq  \textit{$\mathcal{N}\mathcal{P}$}
        \end{align*}
\indent Esta conjetura es una de las más famosas e importantes preguntas abiertas que existen dentro del mundo de la matemática. Fue planteada a mediados de la década de 1960 por J. Edmonds, cuando afirmó que no podría existir un algoritmo 'bueno' (es decir, de tiempo polinómico) para el Problema del Viajante y dio lugar a la definición formal de la Clase \textit{$\mathcal{N}\mathcal{P}$} de Cook(1971) y Levin (1973).\newline
\end{minipage}}
\newline

\noindent\fbox{\begin{minipage}{\dimexpr\textwidth-2\fboxsep-2\fboxrule\relax}
 \subsection*{La conjetura de Edmonds}
        \begin{align*}
            \textit{$\mathcal{P}$} = \textit{$\mathcal{N}\mathcal{P}$} \cap \textit{co-$\mathcal{N}\mathcal{P}$}
        \end{align*}
\indent Esta conjetura también fue propuesta por Edmonds en 1965 y está fuertemente respaldada por evidencia empírica. Se sabe que la mayoría de los problemas que sabemos que pertenecen a \newline $\textit{$\mathcal{N}\mathcal{P}$} \cap \textit{co-$\mathcal{N}\mathcal{P}$}$\newline

\end{minipage}}

\section*{Reducciones Polinomiales}
\indent Es común que para resolver un problema se intente transformar el problema original en uno cuya solución ya es conocida, para luego tomar esa solución y transformarla en una para el problema original. Tomando esta idea, definimos a la \textit{reducción polinomial} de un problema \textbf{P} a un problema \textbf{Q}, como el par de algoritmos polinómicos tal que uno transforma cada instancia \textbf{I} de \textbf{P} en una instancia \textbf{J} de \textbf{Q}, y el otro transforma la solución para una instancia \textbf{J} en una solución de una instancia \textbf{I}. Si existen estos algoritmos, diremos que la reducción existe y que \textbf{P} es \textit{polinómicamente reducible} a \textbf{Q} y lo representamos como $\textit{P} \preceq \textit{Q}$; esta relación entre problemas es reflexiva y transitiva.\newline
\indent Una de las claves de la reducción polinomial es que si $\textit{P} \preceq \textit{Q}$ y existe un algoritmo polinómico que resuelve \textbf{Q} entonces ese algoritmo puede ser convertido en un algoritmo polinómico para resolver \textbf{P}. En símbolos:
\begin{align*}
    \textit{P} \preceq \textit{Q} \land \textit{Q} \in \mathcal{P} \implies \textit{P} \in \mathcal{P}
\end{align*}


\textbf{PONER EJEMPLO PARA REDUCCION}
\newline

\section*{Problemas $\mathcal{NP}$-Completos  -   La clase $\mathcal{NPC}$}
\indent Podemos definir informalmente a los problemas que pertenecen a la clase $\mathcal{NPC}$ como los problemas que pertenecen a la clase $\mathcal{NP}$ que son por lo menos tan complicados de resolver como cualquier problema $\mathcal{NP}$. Formalmente, decimos que un problema P $\in \mathcal{NP}$ es $\mathcal{NPC}$ si $P' \preceq P$ para todo problema P' $\in \mathcal{NP}$.\newline
\indent Para probar que un problema Q $\mathcal{NP}$ es un $\mathcal{NPC}$, es suficiente con encontrar una reducción polinómica de Q a algún P $\in \mathcal{NPC}$ conocido. En símbolos:
\begin{align*}
    \textit{P} \preceq \textit{Q} \land \textit{P} \in \mathcal{NPC} \implies \textit{Q}\in   \mathcal{NPC}
\end{align*}

\textbf{ESCRIBIR SOBRE EL TEOREMA 8.8 Y SI O SI DEL PROBLEMA 8.9 Y TEOREMA 8.10}

\end{document}

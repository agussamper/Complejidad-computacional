\documentclass{article}
\usepackage[spanish]{babel}
\usepackage{graphicx} % Required for inserting images
\usepackage{lipsum}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{setspace}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\usepackage{amsmath}

\setlength{\parskip}{2pt}

\spacing{1.3}

\title{Complejidad computacional}
\author{Agustín Samper, Facundo Llaudet y Guillermo Pereyra}
\date{November 2023}

\begin{document}
\maketitle
La mayoría de los problemas que consideramos en la materia son de 
carácter general, aplicados a todos los miembros de alguna familia de
grafos o dígrafos. Estos problemas pueden ser clasificados dependiendo de su nivel de dificultad.

La dificultad de un problema depende del tiempo empleado para
devolver una respuesta dado un input en específico.

Estos problemas son resueltos mediantes algoritmos, los cuales
los definimos como procedimientos computacionales bien definidos que 
aceptan cualquier instancia del problema como entrada y retorna una
solución al problema como salida. Por ejemplo,
el algoritmo de Prim acepta como entrada un grafo ponderado y retorna un
árbol óptimo.

Por instancia de un problema, nos referimos al
problema aplicado a un miembro específico de la familia. Por ejemplo,
una instancia del problema del árbol recubridor de peso mínimo es el
problema de encontrar un árbol óptimo (árbol recubridor de peso mínimo)
para un grafo ponderado particular.

Entonces, cuando hablamos del nivel de dificultad de un problema, nos
referimos a la complejidad computacional de un algoritmo que lo resuelve,
al número de pasos básicos computacionales (como operaciones aritméticas y comparaciones)
requeridas para su ejecución. Este número depende claramente del tamaño y de la 
naturaleza de la entrada.

Diremos que un algoritmo es polinomial cuando el número de
operaciones que efectúa está acotado por una función polinomial en
el tamaño de su entrada, el algoritmo es llamado \textit{algoritmo
de tiempo polinomial}. Además, está calificado como \textit{tiempo lineal}
si el polinomio es una función lineal, \textit{tiempo cuadrático} si 
es una función cuadrática y así sucesivamente.

\section*{La clase $\mathcal{P}$}
La importancia de algoritmos de tiempo polinomial es que estos algoritmos
generalmente son computacionalmente realizables, incluso para grandes
tamaños de entrada.

El tipo de problemas resolubles mediante algoritmos de tiempo polinómico
lo denotaremos como problemas de clase $\mathcal{P}$.

Un ejemplo de algoritmo en tiempo polinomial (clase $\mathcal{P}$)
es BFS (breadth-first search) para el cual, cada arista es examinada por una posible
inclusión en el árbol solamente dos veces. Otro ejemplo es DFS (depth-first serach)
donde ocurre lo mismo que en BFS. Por lo tanto, cualquiera de estos son
lineales en el número de aristas.

En contraste a los algoritmos de tiempo polinomial, los
algoritmos cuya complejidad es exponencial en el tamaño de su
entrada tienen tiempos de ejecución, los cuales los hacen inutilizables,
incluso para entradas de un tamaño moderado. Por ejemplo, un algoritmo
el cual verifica si dos grafos con n vértices son isomorfos o no 
considerando todas las n! biyecciones entre sus conjuntos de vértices es
realizable solo para pequeños valores de n (específicamente no mayor a 20).

Estos algoritmos dan lugar a una nueva clase de problemas que llamaremos
problemas de clase $\mathcal{NP}$.

\section*{Las Clases $\mathcal{NP}$ y co-$\mathcal{NP}$}
Necesitamos primero definir que un \textit{problema de decisión}
es una pregunta cuya respuesta es 'sí' o 'no'. Tal problema pertenece
a la clase $\mathcal{P}$ si existe un algoritmo de tiempo
polinomial que resuelve cualquier instancia del problema en tiempo
polinomial. En cambio, dada una instancia
cualquiera del problema cuya respuesta es 'sí', si existe alguna forma de 
certificar que la afirmación es válida en tiempo polinomial, entonces este problema
pertenece a la clase $\mathcal{NP}$; tal certificado decimos
que es un certificado sucinto. Análogamente,
un problema pertenecerá a la clase co-$\mathcal{NP}$ si para
una instancia cualquiera del problema cuya respuesta es 'no', existe un
certificado sucinto.

Es inmediato ver que 
$\mathcal{P}$ $\subseteq$ \textit{$\mathcal{NP}$},
pues por definición, para un problema $\mathcal{P}$ existe
un algoritmo que resuelve en tiempo polinomial cualquier instancia
del problema, en particular lo hará para aquellas cuya respuesta es
'sí'. Siguiendo la misma lógica para las instancias cuyas respuestas
es 'no', llegamos a la conclusión que $\mathcal{P}$
$\subseteq$ co$-\mathcal{NP}$. Entonces, podemos
ver que:
\begin{align*}
    \mathcal{P} \subseteq \mathcal{NP}
    \cap co-\mathcal{NP}
\end{align*}

Consideremos, por ejemplo, el problema de determinar
si un grafo es bipartito. Este problema de decisión pertenece
a $\mathcal{NP}$, porque un bipartición es un verificado
sucinto, en efecto, dada una bipartición $(X,Y)$ de un grafo
bipartito $G$, es suficiente verificar que cada vértice de $G$
tiene un extremo en $X$ y otro en $Y$. Además el problema pertenece
a co-$\mathcal{NP}$ ya que un grafo es bipartito si y sólo
si no tiene ciclos impar, y cualquier ciclo, es un certificado sucinto
de que el grafo no es bipartito. Por lo tanto, este problema 
pertenece a $\mathcal{NP} \cap$ co-$\mathcal{NP}$.

Consideremos ahora el problema de si hay un ciclo hamiltoniano.
Si la respuesta el 'si', luego cualquier ciclo hamiltoniano sirve
de certificado sucinto. Sin embargo, si la respuesta es 'no', no
hay un certificado sucinto conocido. A pesar de que claramente
este problema es de la clase $\mathcal{NP}$, no se ha demostrado
que pertenece a co-$\mathcal{NP}$, y es probable que no
pertenezca a esta clase. Pasa lo mismo con el problema de
decision para caminos hamiltonianos.

Hemos señalado tres relaciones de inclusión entre las clases
$\mathcal{P}$, $\mathcal{N}\mathcal{P}$ y
co$-\mathcal{N}\mathcal{P}$, y es natural preguntarse
si estas inclusiones son adecuadas. Debido a que
$\mathcal{P} = \mathcal{N}\mathcal{P}$
si y solo si $\mathcal{P} = $ co-$\mathcal{N}\mathcal{P}$,
surgen dos preguntas fundamentales, ambas de las cuales se han 
planteado como conjeturas. 

\setlength{\fboxsep}{10pt}
\noindent\fbox{\begin{minipage}{\dimexpr\textwidth-2\fboxsep-2\fboxrule\relax}
 \subsection*{La conjetura de Cook-Edmonds-Levin}
        \begin{align*}
            \mathcal{P}  \neq  \mathcal{N}\mathcal{P}
        \end{align*}
Esta conjetura es una de las más famosas e importantes preguntas abiertas que existen dentro del mundo de la matemática. Fue planteada a mediados de la década de 1960 por J. Edmonds, cuando afirmó que no podría existir un algoritmo 'bueno' (es decir, de tiempo polinómico) para el Problema del Viajante y dio lugar a la definición formal de la Clase \textit{$\mathcal{N}\mathcal{P}$} de Cook(1971) y Levin (1973).
\end{minipage}}

\noindent\fbox{\begin{minipage}{\dimexpr\textwidth-2\fboxsep-2\fboxrule\relax}
 \subsection*{La conjetura de Edmonds}
        \begin{align*}
            \mathcal{P} = \mathcal{NP}
            \cap co-\mathcal{N}\mathcal{P}
        \end{align*}
\indent Esta conjetura también fue propuesta por Edmonds en 1965 y está
fuertemente respaldada por evidencia empírica. Se sabe que la mayoría
de los problemas que sabemos que pertenecen a \newline
\textit{$\mathcal{N}\mathcal{P}$} $\cap$ \textit{co-}$\mathcal{N}\mathcal{P}$
también se sabe que pertenecen a $\mathcal{P}$

\end{minipage}}

\section*{Reducciones Polinomiales}
\indent Es común que para resolver un problema se intente transformar el problema original en uno cuya solución ya es conocida, para luego tomar esa solución y transformarla en una para el problema original. Tomando esta idea, definimos a la \textit{reducción polinomial} de un problema \textbf{P} a un problema \textbf{Q}, como el par de algoritmos polinómicos tal que uno transforma cada instancia \textbf{I} de \textbf{P} en una instancia \textbf{J} de \textbf{Q}, y el otro transforma la solución para una instancia \textbf{J} en una solución de una instancia \textbf{I}. Si existen estos algoritmos, diremos que la reducción existe y que \textbf{P} es \textit{polinómicamente reducible} a \textbf{Q} y lo representamos como $\textit{P} \preceq \textit{Q}$; esta relación entre problemas es reflexiva y transitiva.\newline
\indent Una de las claves de la reducción polinomial es que si $\textit{P} \preceq \textit{Q}$ y existe un algoritmo polinómico que resuelve \textbf{Q} entonces ese algoritmo puede ser convertido en un algoritmo polinómico para resolver \textbf{P}. En símbolos:
\begin{align*}
    P \preceq Q \land Q \in \mathcal{P} \implies P \in \mathcal{P}
\end{align*}

\textbf{PONER EJEMPLO PARA REDUCCION}


\section*{Problemas $\mathcal{NP}$-Completos  -   La clase $\mathcal{NPC}$}
Podemos definir informalmente a los problemas que pertenecen a la clase $\mathcal{NPC}$ como los problemas que pertenecen a la clase $\mathcal{NP}$ que son por lo menos tan complicados de resolver como cualquier problema $\mathcal{NP}$. Formalmente, decimos que un problema P $\in \mathcal{NP}$ es $\mathcal{NPC}$ si $P' \preceq P$ para todo problema P' $\in \mathcal{NP}$.

Para probar que un problema Q $\mathcal{NP}$ es un $\mathcal{NPC}$, es suficiente con encontrar una reducción polinómica de Q a algún P $\in \mathcal{NPC}$ conocido. En símbolos:
\begin{align*}
    P \preceq Q \land P \in \mathcal{NPC} \implies Q\in   \mathcal{NPC}
\end{align*}

\textbf{ESCRIBIR SOBRE EL TEOREMA 8.8 Y SI O SI DEL PROBLEMA 8.9 Y TEOREMA 8.10}

\end{document}
